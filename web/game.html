<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Zuma — by.Tara (Frog shooter)</title>
<style>
  :root{
    --bg1:#061022; --accent:#ffd166; --panel:#071428;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),#031026);font-family:Inter,Arial,sans-serif;color:#fff;-webkit-font-smoothing:antialiased}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:8px;gap:8px;height:100vh;box-sizing:border-box}
  .top{width:100%;max-width:920px;display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:18px;font-weight:800}
  .canvas-wrap{position:relative;width:100%;max-width:920px;flex:1;display:flex;align-items:center;justify-content:center;min-height:420px}
  /* make canvas container responsive */
  .game-stage{width:100%;height:100%;border-radius:14px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.6);background:var(--panel);display:flex;align-items:center;justify-content:center}
  canvas{display:block; width:100%; height:100%; touch-action:none; -webkit-user-select:none; user-select:none;}
  .hud{position:absolute;left:12px;top:12px;display:flex;gap:10px;align-items:center;z-index:40}
  .hud .pill{background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px}
  .controls{position:absolute;right:12px;top:12px;z-index:50;display:flex;gap:10px}
  button{background:var(--accent);border:0;padding:8px 12px;border-radius:10px;font-weight:700;font-size:13px;cursor:pointer}
  .brand{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.28);padding:6px 10px;border-radius:999px;font-weight:700;z-index:30}
  .game-over{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);padding:20px 28px;border-radius:10px;color:#fff;font-weight:800;display:none;z-index:60;pointer-events:none}
  .game-over.show{display:block}
  .footer-note{width:100%;max-width:920px;color:#cbd5e1;font-size:13px;display:flex;justify-content:space-between;padding-top:6px}
  @media (max-width:600px){
    h1{font-size:16px}
    .hud .pill{font-size:12px;padding:6px 8px}
    button{padding:7px 10px;font-size:12px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <h1>Zuma — by.Tara</h1>
    <div style="opacity:0.9;font-size:13px">Frog shooter</div>
  </div>

  <div class="canvas-wrap">
    <div class="game-stage" id="stage">
      <canvas id="gameCanvas"></canvas>

      <div class="hud" aria-hidden="true">
        <div class="pill" id="scoreP">Score: 0</div>
        <div class="pill" id="levelP">Level 1</div>
      </div>

      <div class="controls">
        <button id="resetBtn" type="button" aria-label="Reset game">Reset</button>
      </div>

      <div class="brand">by.Tara</div>

      <div class="game-over" id="gameOver">Game Over<br><span style="font-weight:400;font-size:14px">Tekan Reset untuk main lagi</span></div>
    </div>
  </div>

  <div class="footer-note"><div>Tap to shoot • Drag to aim</div><div>Best view: Add to Home Screen (Android)</div></div>
</div>

<script>
/* ====== Responsive HD canvas setup ====== */
const canvas = document.getElementById('gameCanvas');
const stage = document.getElementById('stage');
const scoreP = document.getElementById('scoreP');
const levelP = document.getElementById('levelP');
const resetBtn = document.getElementById('resetBtn');
const gameOverEl = document.getElementById('gameOver');

// scale canvas for crisp HD
function fitCanvas(){
  // size of stage in CSS pixels
  const rect = stage.getBoundingClientRect();
  // choose a logical resolution aspect — we pick 1280x800 base and scale to width
  const cssW = rect.width;
  const cssH = rect.height;
  // device pixel ratio but cap for perf
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing ops
}
const ctx = canvas.getContext('2d');

/* ====== Game parameters & state ====== */
let WIDTH = 1280, HEIGHT = 800;
let DPR = Math.min(window.devicePixelRatio || 1, 2);

let center = {x: WIDTH/2, y: HEIGHT/2};
let pathRadius = 300;
let ballR = 28;
let baseSpeed = 0.018;

const BALL_COLORS = ['#ff6b6b','#ffd166','#6ef0b8','#6fb3ff','#c77dff'];

let state = {
  chain: [],
  score: 0,
  level: 1,
  shooter: { angle: -Math.PI/2, next: 0 },
  fired: null,
  particles: [],
  trails: [],
  spawnCounter: 0,
  gameOver: false,
  lastTime: 0
};

/* utility */
function randIdx(){ return Math.floor(Math.random()*BALL_COLORS.length); }
function posFromT(t){
  const maxTurns = 2.2;
  const theta = Math.PI*2*maxTurns*(t) + Math.PI/2;
  const r = pathRadius * t;
  return { x: center.x + r*Math.cos(theta), y: center.y + r*Math.sin(theta), theta };
}

/* ====== init/reset ====== */
function updateHUD(){
  scoreP.textContent = 'Score: ' + state.score;
  levelP.textContent = 'Level ' + state.level;
}
function resetGame(){
  state.chain = [];
  state.score = 0;
  state.level = 1;
  state.shooter.angle = -Math.PI/2;
  state.shooter.next = randIdx();
  state.fired = null;
  state.particles = [];
  state.trails = [];
  state.spawnCounter = 0;
  state.gameOver = false;
  gameOverEl.classList.remove('show');
  // initial chain
  for(let i=0;i<12;i++) state.chain.push({ t: 0.9 - i*0.045, idx: i % BALL_COLORS.length });
  updateHUD();
  // ensure loop runs
  if (!animating) {
    animating = true;
    requestAnimationFrame(loop);
  }
}

/* ====== audio (WebAudio lightweight) ====== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if (!audioCtx) audioCtx = new AudioCtx(); return audioCtx; }
function playShort(freq=800, type='sine', dur=0.16){
  try{
    const c = ensureAudio(), o = c.createOscillator(), g = c.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, c.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + dur);
    o.connect(g); g.connect(c.destination); o.start(); o.stop(c.currentTime + dur);
  }catch(e){}
}

/* ====== spawn particle effects ====== */
function spawnPop(x,y,idx,count=18){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 1 + Math.random()*3;
    state.particles.push({
      x, y,
      vx: Math.cos(a)*s*(1+Math.random()),
      vy: Math.sin(a)*s*(1+Math.random()),
      life: 600 + Math.random()*300,
      age: 0,
      idx
    });
  }
  playShort(1200,'triangle',0.14);
}

/* ====== game logic update ====== */
function levelCfg(lv){
  return { speed: baseSpeed + (lv-1)*0.004, spawnInterval: Math.max(380,900 - (lv-1)*80), target: 60*lv };
}

function update(dt){
  if (state.gameOver) return;
  const cfg = levelCfg(state.level);

  // move chain towards center
  for (let b of state.chain){
    b.t -= cfg.speed * dt;
    if (b.t <= 0.06){
      state.gameOver = true;
      gameOverEl.classList.add('show');
      return;
    }
  }

  // spawn new balls at outer end
  state.spawnCounter += dt * 16.666;
  if (state.spawnCounter > cfg.spawnInterval / 16.666){
    state.spawnCounter = 0;
    const lastT = state.chain.length ? state.chain[state.chain.length-1].t : 0.98;
    state.chain.push({ t: lastT + 0.055 + Math.random()*0.03, idx: randIdx() });
  }

  // update fired projectile
  if (state.fired){
    state.fired.x += state.fired.vx * dt;
    state.fired.y += state.fired.vy * dt;
    state.trails.push({ x: state.fired.x, y: state.fired.y, alpha: 0.9, life: 120 });
  }

  // update particles and trails
  for (let p of state.particles){
    p.age += dt*16.666;
    p.x += p.vx * dt * 0.9;
    p.y += p.vy * dt * 0.9;
    p.vx *= 0.995; p.vy *= 0.995;
  }
  for (let i=state.particles.length-1;i>=0;i--) if (state.particles[i].age > state.particles[i].life) state.particles.splice(i,1);
  for (let i=state.trails.length-1;i>=0;i--){
    state.trails[i].life -= dt*16.666;
    state.trails[i].alpha -= 0.02*dt;
    if (state.trails[i].life <= 0 || state.trails[i].alpha <= 0) state.trails.splice(i,1);
  }

  if (state.fired) handleCollision();

  if (state.score >= levelCfg(state.level).target){
    state.level++;
    updateHUD();
    for (let i=0;i<4;i++){
      const last = state.chain.length ? state.chain[state.chain.length-1].t : 0.9;
      state.chain.push({ t: last + 0.045*(i+1), idx: randIdx() });
    }
    playShort(640,'sine',0.38);
  }
}

/* collision handling */
function handleCollision(){
  if (!state.fired) return;
  for (let i=0;i<state.chain.length;i++){
    const b = state.chain[i];
    const ppos = posFromT(Math.max(0.03, b.t));
    const dx = state.fired.x - ppos.x, dy = state.fired.y - ppos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= ballR * 1.8){
      const insertIndex = i;
      const insertT = Math.min(b.t + 0.02, 0.98);
      state.chain.splice(insertIndex, 0, { t: insertT, idx: state.fired.idx });
      state.fired = null;
      runRemoval(insertIndex);
      return;
    }
  }
  // out of bounds
  if (state.fired.x < -100 || state.fired.x > canvas.width +100 || state.fired.y < -100 || state.fired.y > canvas.height +100) state.fired = null;
}

/* remove sequences */
function runRemoval(idx){
  const colorIdx = state.chain[idx].idx;
  let left = idx, right = idx;
  while (left-1 >=0 && state.chain[left-1].idx === colorIdx) left--;
  while (right+1 < state.chain.length && state.chain[right+1].idx === colorIdx) right++;
  const cnt = right - left + 1;
  if (cnt >= 3){
    let avgX=0, avgY=0;
    for (let k=left;k<=right;k++){
      const pos = posFromT(state.chain[k].t);
      avgX += pos.x; avgY += pos.y;
    }
    avgX /= cnt; avgY /= cnt;
    spawnPop(avgX, avgY, colorIdx, Math.min(36, 8 + cnt*5));
    state.score += cnt * 12;
    updateHUD();
    state.chain.splice(left, cnt);
    if (cnt >= 5){
      const mid = Math.max(0, Math.min(state.chain.length-1, left));
      state.chain.splice(mid, 0, { t: 0.5 + Math.random()*0.3, idx: randIdx() });
    }
  }
}

/* ====== drawing ====== */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cssW = canvas.width / DPR, cssH = canvas.height / DPR;
  // update centers based on css dims
  center.x = cssW/2; center.y = cssH/2;
  pathRadius = Math.min(cssW, cssH) * 0.36;

  // background vignette
  const g = ctx.createRadialGradient(center.x, center.y - 80, 20, center.x, center.y, Math.max(cssW, cssH));
  g.addColorStop(0, 'rgba(255,255,255,0.02)'); g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g; ctx.fillRect(0,0,cssW,cssH);

  // draw path
  ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.beginPath();
  for (let t=0; t<=1.001; t+=0.003){
    const p = posFromT(t);
    if (t===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();

  // draw chain (outer -> inner)
  for (let i=state.chain.length-1;i>=0;i--){
    const b = state.chain[i];
    const p = posFromT(Math.max(0.03, b.t));
    const scale = 1 + (0.9 - Math.max(0.03, b.t))*0.12;
    drawBall(p.x, p.y, ballR*scale, BALL_COLORS[b.idx]);
  }

  // draw fired ball
  if (state.fired) drawBall(state.fired.x, state.fired.y, ballR, BALL_COLORS[state.fired.idx]);

  // particles
  for (let p of state.particles){
    const lifeRatio = 1 - p.age / p.life;
    ctx.beginPath();
    ctx.globalAlpha = Math.max(0, lifeRatio);
    ctx.fillStyle = BALL_COLORS[p.idx] || '#fff';
    ctx.arc(p.x, p.y, 3 + (1-lifeRatio)*5, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // trails
  for (let tr of state.trails){
    ctx.beginPath();
    ctx.globalAlpha = Math.max(0, tr.alpha);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.arc(tr.x, tr.y, tr.r || 3, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // center hole
  ctx.beginPath(); ctx.fillStyle = 'rgba(2,6,10,0.98)'; ctx.arc(center.x, center.y, 34, 0, Math.PI*2); ctx.fill();
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.stroke();

  // draw frog shooter at bottom with rotation
  drawFrog();
}

/* helper: draw a glossy ball */
function drawBall(x,y,r,color){
  ctx.beginPath(); ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 12; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
  const lg = ctx.createRadialGradient(x - r*0.4, y - r*0.6, r*0.1, x, y, r);
  lg.addColorStop(0, 'rgba(255,255,255,0.45)');
  lg.addColorStop(0.25, 'rgba(255,255,255,0.12)');
  lg.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.beginPath(); ctx.fillStyle = lg; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(0,0,0,0.28)'; ctx.stroke();
}

/* draw simple frog sprite using canvas shapes */
function drawFrog(){
  const frogW = Math.min(160, Math.max(96, Math.min(220, canvas.width/ DPR * 0.22)));
  const frogH = frogW;
  const fx = center.x - frogW/2;
  const fy = center.y + (pathRadius * 0.6);
  ctx.save();
  ctx.translate(fx + frogW/2, fy + frogH/2);
  ctx.rotate(state.shooter.angle - Math.PI/2);
  // body
  ctx.beginPath();
  ctx.fillStyle = '#3CB44B';
  ctx.ellipse(0, 6, frogW*0.42, frogH*0.32, 0, 0, Math.PI*2);
  ctx.fill();
  // head
  ctx.beginPath();
  ctx.ellipse(0, -22, frogW*0.34, frogH*0.28, 0, 0, Math.PI*2);
  ctx.fill();
  // eyes
  ctx.fillStyle = '#FFE0A0';
  ctx.beginPath(); ctx.ellipse(-frogW*0.15, -30, frogW*0.08, frogW*0.1, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(frogW*0.15, -30, frogW*0.08, frogW*0.1, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(-frogW*0.13, -30, frogW*0.035, frogW*0.045, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(frogW*0.17, -30, frogW*0.035, frogW*0.045, 0, 0, Math.PI*2); ctx.fill();
  // mouth
  ctx.strokeStyle = '#103010'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -12, frogW*0.18, 0.15*Math.PI, 0.85*Math.PI); ctx.stroke();
  ctx.restore();
}

/* ====== input handling ====== */
let dragging = false, lastDown = {x:0,y:0};

function rotateToClient(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const cx = rect.left + center.x * (rect.width / (canvas.width / DPR));
  const cy = rect.top + center.y * (rect.height / (canvas.height / DPR));
  const dx = clientX - cx;
  const dy = clientY - cy;
  state.shooter.angle = Math.atan2(dy, dx) + Math.PI/2;
}

canvas.addEventListener('pointerdown', (e) => {
  dragging = true;
  lastDown.x = e.clientX; lastDown.y = e.clientY;
  rotateToClient(e.clientX, e.clientY);
  try{ ensureAudio(); }catch(e){}
  e.preventDefault();
});
window.addEventListener('pointermove', (e) => {
  if (!dragging) return;
  rotateToClient(e.clientX, e.clientY);
});
window.addEventListener('pointerup', (e) => {
  if (!dragging) return;
  const dx = e.clientX - lastDown.x;
  const dy = e.clientY - lastDown.y;
  if (Math.sqrt(dx*dx + dy*dy) < 12) shoot();
  dragging = false;
});
canvas.addEventListener('click', (e) => {
  rotateToClient(e.clientX, e.clientY);
  shoot();
});

/* ====== shooting ====== */
function shoot(){
  if (state.gameOver) return;
  if (state.fired) return;
  const speed = Math.max(10, (canvas.width/canvas.height) * 10);
  const startX = center.x + Math.cos(state.shooter.angle) * -90;
  const startY = center.y + Math.sin(state.shooter.angle) * -90;
  const vx = Math.cos(state.shooter.angle) * -speed;
  const vy = Math.sin(state.shooter.angle) * -speed;
  state.fired = { x: startX, y: startY, vx, vy, idx: state.shooter.next };
  state.shooter.next = randIdx();
  playShort(820,'sine',0.16);
}

/* ====== main loop ====== */
let animating = false;
function loop(ts){
  if (!state.lastTime) state.lastTime = ts;
  const dt = (ts - state.lastTime) / 16.666;
  state.lastTime = ts;
  update(dt);
  draw();
  if (!state.gameOver) requestAnimationFrame(loop);
  else animating = false;
}

/* ====== event binding ====== */
resetBtn.addEventListener('click', () => {
  resetGame();
});

/* initial sizing & start */
function onResize(){
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  fitCanvas();
  // set logical sizes
  WIDTH = canvas.width / DPR;
  HEIGHT = canvas.height / DPR;
  center.x = WIDTH/2; center.y = HEIGHT/2;
  if (!animating) { animating = true; requestAnimationFrame(loop); }
}
window.addEventListener('resize', onResize);
onResize();
resetGame();

</script>
</body>
</html>
